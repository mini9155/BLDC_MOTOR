# BLDC_MOTOR
Control BLDC motor.


# BLDC 모터 제어.

## BLDC AC 모터를 제어하기 위한 프로젝트

### RTU 방식을 이용한 모터 제어어

- 방식
  - Modbus RTU
- 사용 언어
  - Python
- 사용모듈
  - ver 1 : pymodbus, PySide6, sys
  - ver 2 : pymodbus, PySide6, logging, time, sys
  - ver 3 : Serial, sturct, crcmod, sys
- 제작 기간
    - 1달
- 통신 방식
  - RS-485


1. 모드버스 RTU
  - Modbus RTU protocol은 RS-485나 RS-232등과 같이 serial 통신 환경에서 동작하기 위한 Modbus protocol의 한 종류이다. 이 protocol은 장치 ID를 통하여 각 장치를 구분하고 CRC를 이용하여 에러를 확인한다
  - 슬레이브 주소 - 1byte, 함수 코드 1 byte, 주소 High - 1byte, 주소 Low - 1byte, Data - 2byte, CRC16 - 2bye
  - ex) 0x1 0x6 0x78 0x0 0x1 0xc8 0x13 <- 이런식으로 구성이 된다
  - 끝에 2자리인 CRC16 (0xc8, 0x13)은 계산식이 따로 있으나 pymodbus 혹 crcmod의 함수를 빌려쓰면 편하다
  - 사용한 함수 코드
    - 04 Read Input Registers 3x (30001-39999) - 상태를 읽을 수 있다
    - 06 Write Single Register 0x (40001-39999) - 명령을 내릴 수 있다.
  - 시리얼로 데이터를 받았을 떄 이해하기 힘든 경우 뒤에 crc16 2개 뺴고, 앞에 슬레이브 아이디, 함수 코드를 제외하고 읽어보면 도움이 된다

2. 버전 및 방식을 바꾼 이유
  - 버전1은 아무 지식도 없는 상태에서 모터 제어부터 시작해보기 위해 간단한 인터페이스와 작동 위주의 코드를 작성하기 시작했다
  - 버전2는 간단한 기능 명령 처리 후 어느 정도의 기능 처리 및 이동 거리를 계산하기 위해 logging 모듈을 사용하기로 하였다.
  - 버전3은 logging 모듈로 데이터를 받아올 시 받아들이는 데이터가 많고 그 중에서 원하는 메세지만 받아들이기에는 변칙적인 부분이 있어 Serial 모듈을 이용하게 되었다.

  
3. 버전을 걸치면서 배우게 된 점
  - 버전2에서는 logging 중 emit 이란 모듈을 통해 메세지를 받아오는 방법을 배웠다.
  - 버전2에서 버전3로 넘어가기 전 라이브러리의 코드를 살펴보며 굳이 외부 모듈을 쓰지 않아도 내가 원하는 영역을 구현시킬 수 있는 힌트를 얻었다.
  - 모듈을 살펴보며 클래스의 구조 등을 알게 되었다.
  - 버전 3에서는 메세지를 바이트로 쓰는 방법과 바이트로 패킹을 하는 struct 모듈을 사용해보며 새로운 부분을 알게 되었다.

4. 주요 코드 설명
   - 사용자가 코드를 따로 작성하여 모터를 제어하기에는 오류가 많을 듯 하여 함수 안에 하드 코딩을 하였다. 함수 내부에 리스트 형식으로 주소를 만든 후 sturct.pack이라는 함수를 사용하여 바이트로 변환하였다.
   - 드라이버로 부터 메세지를 받은 후 for을 이용하여 리스트에 추가하면 알아서 메세지가 int 형식으로 바뀌어서 여기서 추가작업을 해준 것은 없다.
   - 이외에는 읽으면 이해될 수준으로 작성을 하였다. 
  
------------------------------------------------------------

문제 해결 방법

1. 모든 한 가지에 틀어박혀서는 문제가 해결되지 않는다
  - 처음 메뉴얼에 제시된 통신 속도는 9600 이었다. 이걸로 여러번 시도를 해보았고 되지 않는 걸 보며 모터 불량을 생각하였고 통신 속도 및 다른 부분을 시도할 생각을 하지 못하였다. 똑같은 걸로 하나만 시도한다고 되는 게 아니라 여러가지 가능성을 열어두고 이것저것 해봐야 하는 걸 배웠다.

2. 너무 외부 라이브러리에 의존하지 않는 점이다
  - Modbus도 기본은 Serial이다. 하지만 외부 모듈만 찾는데 급급하여 외부 모듈만 사용하였고 큰 틀 내가 맞추어 가니 불편한 점 또한 많았다. 로깅 메세지 또한 그런 문제였다. 메세지를 내가 원하는 양 만큼 받아오면서 주소를 해석하여 모터의 상태를 불러 올 수 있게 되었다.

3. 알고리즘이 얼마나 중요한지 알게 되었다
  - 프로그램은 알고리즘을 작성한대로 구현하게 된다면 추가적인 필요한 부분이 생겼을 경우 추가가 쉽지만 만약 그렇지 않은 경우 모듈을 하나 둘 추가하다 보면 코드가 어려워진다. 필요한 기능을 정리 후 하나 둘 성성 및 연계 시켜야한다는 점을 꺠닭았다.

4. 바이트가 꺠져서 보이는 현상
- 꺠지는 게 아니었다. 그냥 일정값 이상 부터는 아스키코드로 변환되어서 문자로 보이는 것 뿐이었다. for문으로 부분마다 받아와주면 알아보기 쉽게 정수로 변환하여 준다.

------------------------------------------------------------



-방식
  - 아두이노 우노
- 사용 프로그램
  - 아두이노IDE
- 제작기간
  - 1달
- 통신방식
 - 모터 <-> 아두이노 : I/O
 - 아두이노 <-> PC : 시리얼

1. I/O 방식
   - I/O 안에도 크게 2가지 방식이 있다. 디지털은 신호 0,1을 불연속적인 신호, 아날로그 신호 연속적인 신호를 이용하여 입력하는 방식이다.
   - 예를 들어 전구의 전원을 켜는 방식은 디지털 제어에 가깝다. 켜지거나 꺼지거나 하는 2가지의 경우의 수 밖에 없으니까, 하지만 밝기를 조절하는 건 아날로그라고 볼 수 있다.
   - 펄스 제어는 디지털 방식에 가깝다. 0과 1의 신호를 번갈아 가면서 1주기라는 개념으로 제어를 한다.
   - 1주기 = T = 1/f 이다. 이 단위는 1초 단위이다.
   - 1주기는 신호가 HIGH 에서 LOW로 변한 후 다시 HIGH 되기까지의 시간을 말한다.
      _______        
      |     |       |
      |     |_______|

      |<---1주기--->|

2. 모터 관련
   - 모터의 속도는 가변저항을 이용한 전압으로 제어가 가능하고 혹은 펄스를 입력하여 속도가 조절이 가능하다.
   - 드라이버와 같이 딸려오는 케이블이 있는데 이 케이블은 가변 저항을 활용하여 저항이 낮아지면 속도가 점점 빨라지는 방식이다. 저항이 줄어들어 전압이 강해지면 모터도 쓸 수 있는 에너지가 많으니까 속도도 빨라진다고 생각하면 편할 거 같다.

3. 엔코더 관련
   - 엔코더는 증분식, 절대식이 있다. 증분식은 상대적인 방식, 절대식은 말그대로 절대적 방식이다.
   - 절대식은 Absolute, 증분식은 Incrementa Encoder라고도 부른다.
   - 둘 다 광학신호를 이용하지만 증분식은 일정 간격에 배열된 슬롯의 수를 측정하여 카운트하는 방식이고, 절대식은 슬롯에 이진코드를 작성하여 광학센서를 이용해 값을 읽는 방식으로 자신의 위치를 기억할 수 있다.
   - 구매한 GGM의 모터 드라이버인 GUB는 엔코더 출력이 라인 드라이버 방식이다. 오픈 콜렉터와 라인 드라이버 방식이 있는데 오픈 콜렉터는 정확하게는 이해하지 못하였지만 트랜지스터를 ON/OFF 하여 전류량을 10mA 정도로 이 전류를 만족하면, DC 5 ~ 24V에 유연하게 대처할 수 있다. 라인 드라이버 방식은 1개의 신호가 나오면 그 신호를 반전시켜 2개로 출력한다.
   - 라인 드라이버 방식에도 Single_ended 방식 Defferential 방식이 있다.
   - Single_ended는 하나의 그라운드를 이용해서 +,- 신호인지 구분하는 방식으로 rs-232통신이 이에 해당한다
   - Defferential은 2개의 신호를 이용하여 기존 신호를 반전 시켜 2개의 신호를 출력시킨다. 이 2개의 신호를 전달하여 끝단에서 다시 합치는 방식으로 받는 쪽은 라인 리시버 IC가 필요하다. 주파수가 높을수록 노이즈에 강하다는 장점이 있는데 이 방식을 통하여 노이즈를 줄여줄 수 있다는 장점이 있다.
   - 라인리시버(26LS32)를 이용하여 신호를 합쳐보려하였으니 아두이노의 문제점인지 혹은 사용 미숙인지는 파악하지 못하였다.
   - 사용중인 드라이버에서는 A,B,z 값이 나오는데 A와 B는 90도의 위상차가 있고 이 위상차로 정방향인지 역방향인지 구분이 가능하고 Z를 이용하여 바퀴 수를 계산할 수 있다. 즉 A,B의 값을 이용하여 회전수를 카운트 하고 Z의 값이 입력이 되면 A,B의 값은 초기화, 1바퀴를 돌았다는 것을 알 수 있다.  

4. 아두이노 우노로 모터를 제어하지 못하는 이유
   - 아두이노 디지털 핀은 최대 주파수가 980hz이다. 제어해야하는 500rpm의 주파수가 8333hz인데 턱 없이 부족한 수준이다.
   - 아두이노 우노에 내장되어 있는 ATmega328p를 직접적으로 제어를 하면 주파수를 변경할 수 있으나ㅏ 본래의 용도에 맞게 설계된 걸 변경한 만큼 오차가 발생할 가능성이 크다고 한다.
   - 아두이노 우노의 클럭 주파수 즉 작업 속도는 16MHz이다. 하지만 우노의 같은 경우에는 고속으로 자료를 처리하는 목적이 아니므로 중간에 데이터를 놓치는 경우도 발생하고 500rpm이 발생하고 엔코더의 값과 처리하는 데이터들의 속도만 계산하여봤을 떄 최소 550kH 즉 우노의 30퍼 이상의 해당하는 작업을 차지하고 시간을 따진다면 1.6us 정도가 된다.
   - 출력 주파수의 30%를 차지한다고 해도 우노로 버거운지는 아직 이해가 되지 않는다. 하지만 GGM 드라이버 개발팀에 문의 했을 시 16Mhz로는 제어는 힘들다고 한다.
   - 또한 아두이노 우노가 감지하는 기준 전압은 5V 인데 라인 리시버로 데이터를 합쳐도 5V가 나오지 않는다(다시 시도해봐야함). 즉 5V가 나오지 않는다면 디지털 값인 1로 인식할수가 없고 운이 좋아 읽었다고 해도 정확도가 많이 떨어지는 부분이 있어 신뢰할 수 없다.
   - 보다 정확한 제어를 위해서는 MCU 칩을 바로 코딩하여야 하는데 낮은 단계의 코딩이라 배운 적이 없기도 하고 메모리 관리까지 해주어야 해서 어려운 점이 많다.
  
------------------------------------------------------------

### 아두이노 UNO를 이용한 모터 제어 (I/O 방식 제어 및 레지스터 직접 제어)

- 방식
  - 아두이노 우노
- 사용 프로그램
  - 아두이노IDE, 파이썬
- 제작 기간
  - 1달
- 통신 방식 : UART 통신

1. 시작하면서 
   - 전자통신과를 나왔지만 나에게 관심이 없는 분야라고 생각하던 임베디드를 처음 해보았다. 처음에는 아두이노의 코드조차 몰랐던 내가 이젠 찾아보다보니 메모리라는 것도 이해하기 시작했다. 위에 글에도 적었듯이 왜 16Mhz라는 최대 클럭수로 왜 제어가 안되는지 궁금하였고 못할거라고 하였지만 찾아보다보니 아두이노에서 핀 제어는 폴링 방식이라 속도가 느리다는 것을 알게 되었고 처리하기 전에 작동을 시키려고 하니 당연히 되지 않는 것이었다.이를 참고하여 레지스터를 직접 제어하여 원하는 모터의 속도가 나오는 것을 확인하였고 천천히 진행하였다. 이를 진행하면서 C언어 문법 및 자료형에 대해서 자세히 알 수 있게 되었고 임베디드 관련 분야에 관심을 가지게 되었다.

2. AVR 코드를 이용한 레지스터 제어
   - 처음에는 직접 타이머 함수를 만들어서 제어를 해보려고 하였다. 하지만 찾아보던 중 AVR 컴파일러에 포함되어 있던 _delay_us 라는 함수를 알게 되었고 이를 이용하여 모터 제어 프로그램을 만들기로 하였다.
   - 통신 부분에서 많이 찾아보지는 않았지만 기존에 진행하였던 RTU 방식에 영감을 받아 나에게는 어차피 슬레이브 아이디가 필요가 없으니 오류 코드 검증 코드를 넣자고 생각하였고 [시작비트, 데이터 길이, 데이터++,종료비트] 이렇게 구성하였다. avr 코드에서는 만약 저기서 시작비트, 데이터길이 등등이 만족되지 않는다면 바로 false를 반환하게 하고 실행문에 접근을 하지 못하도록 하였다.
  

3. PySide6를 이용한 Ui 제어
   - PySide6로 기존에 UI를 제작하였고 컴퓨터에도 작동이 되는 걸 확인했는데 어느날 갑자기 무한 대기가 걸리면서 self.ui.load()? 가 작동하지 않았다. 다른 방법을 찾아보니 파이썬 코드로 변환 후 메인에서 init() 함수로 변환 후 작동할 수 있게 되어서 이 방식을 이용하였다. 시간이 빠듯한 관계로 8비트 즉 255 이상의 값은 UART 통신으로 전달 받지 않았다. 대신 10 단위로 10을 나눠서 전달 후 아두이노 측에서 10을 곱해주는 방식을 이용하였다.
  
4. 차등 엔코더 신호
   - 프로그래밍하면서 차등 엔코더 신호의 값을 하나로 합쳐주는 게 젤 어려웠던 거 같다. 회로랑은 담을 쌓았던 나라서 그랬던 거 같다. 전원은 모터 드라이버에서 나오는 DC 5V를 이용하였고 IC는 라인 리시버인 AM26LS32 를 이용하였다. 이걸 진행하면서 노이즈로 인하여 신호가 제대로 합쳐지지 않는다던지, 잘못된 배선으로 인하여 IC가 너무 뜨거워져서 여러 개를 구매한다던지 여러 불편 사항들이 많았지만, 제조사 측과 계속 질문을 통하여 팁?을 얻고 인터넷을 계속 참고하여 마침내 5V의 엔코더 신호를 받는데 성공하였다.
  
5. 엔코더 신호 인터럽트로 받기
  - 엔코더 신호는 너무 빨라서 일반 방식으로 받기에는 너무 힘든 부분이 많았다. 1회전당 1000 분해능이고 100:1 감속기를 이용하였으니까 100rpm이면 100000가 들어오는 것이다. 그래서 찾아보니 인터럽트라는 기능이 있었고 이 인터럽트를 이용하면 신호가 RISING, FALLING 되는 순간에만 신호를 받아올 수 있고, 또한 코드가 실행 중 신호가 발생하면 이 인터럽트 라는 기능이 모든 걸 중단 시키고 내가 정의한 함수를 실행 후 다시 작업으로 복귀하는 기능을 수행하여서 모터에 신호를 주는 것과 동시에 신호를 받아오는 것 둘 다 어렵지 않았다. 인터럽트 실행 시 속도가 살짝 느려지기는 하지만 어느 정도 허용이 가능한 부분이다.

   

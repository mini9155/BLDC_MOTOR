# BLDC_MOTOR
Control BLDC motor.


# BLDC 모터 제어.

## BLDC AC 모터를 제어하기 위한 프로젝트

- 방식
  - Modbus RTU
- 사용 언어
  - Python
- 사용모듈
  - ver 1 : pymodbus, PySide6, sys
  - ver 2 : pymodbus, PySide6, logging, time, sys
  - ver 3 : Serial, sturct, crcmod, sys
- 제작 기간
    - 1달
- 통신 방식
  - RS-485


1. 모드버스 RTU
  - Modbus RTU protocol은 RS-485나 RS-232등과 같이 serial 통신 환경에서 동작하기 위한 Modbus protocol의 한 종류이다. 이 protocol은 장치 ID를 통하여 각 장치를 구분하고 CRC를 이용하여 에러를 확인한다
  - 슬레이브 주소 - 1byte, 함수 코드 1 byte, 주소 High - 1byte, 주소 Low - 1byte, Data - 2byte, CRC16 - 2bye
  - ex) 0x1 0x6 0x78 0x0 0x1 0xc8 0x13 <- 이런식으로 구성이 된다
  - 끝에 2자리인 CRC16 (0xc8, 0x13)은 계산식이 따로 있으나 pymodbus 혹 crcmod의 함수를 빌려쓰면 편하다
  - 사용한 함수 코드
    - 04 Read Input Registers 3x (30001-39999) - 상태를 읽을 수 있다
    - 06 Write Single Register 0x (40001-39999) - 명령을 내릴 수 있다.
  - 시리얼로 데이터를 받았을 떄 이해하기 힘든 경우 뒤에 crc16 2개 뺴고, 앞에 슬레이브 아이디, 함수 코드를 제외하고 읽어보면 도움이 된다

2. 버전 및 방식을 바꾼 이유
  - 버전1은 아무 지식도 없는 상태에서 모터 제어부터 시작해보기 위해 간단한 인터페이스와 작동 위주의 코드를 작성하기 시작했다
  - 버전2는 간단한 기능 명령 처리 후 어느 정도의 기능 처리 및 이동 거리를 계산하기 위해 logging 모듈을 사용하기로 하였다.
  - 버전3은 logging 모듈로 데이터를 받아올 시 받아들이는 데이터가 많고 그 중에서 원하는 메세지만 받아들이기에는 변칙적인 부분이 있어 Serial 모듈을 이용하게 되었다.

  
3. 버전을 걸치면서 배우게 된 점
  - 버전2에서는 logging 중 emit 이란 모듈을 통해 메세지를 받아오는 방법을 배웠다.
  - 버전2에서 버전3로 넘어가기 전 라이브러리의 코드를 살펴보며 굳이 외부 모듈을 쓰지 않아도 내가 원하는 영역을 구현시킬 수 있는 힌트를 얻었다.
  - 모듈을 살펴보며 클래스의 구조 등을 알게 되었다.
  - 버전 3에서는 메세지를 바이트로 쓰는 방법과 바이트로 패킹을 하는 struct 모듈을 사용해보며 새로운 부분을 알게 되었다.

4. 주요 코드 설명
   - 사용자가 코드를 따로 작성하여 모터를 제어하기에는 오류가 많을 듯 하여 함수 안에 하드 코딩을 하였다. 함수 내부에 리스트 형식으로 주소를 만든 후 sturct.pack이라는 함수를 사용하여 바이트로 변환하였다.
   - 드라이버로 부터 메세지를 받은 후 for을 이용하여 리스트에 추가하면 알아서 메세지가 int 형식으로 바뀌어서 여기서 추가작업을 해준 것은 없다.
   - 이외에는 읽으면 이해될 수준으로 작성을 하였다. 
  
------------------------------------------------------------

문제 해결 방법

1. 모든 한 가지에 틀어박혀서는 문제가 해결되지 않는다
  - 처음 메뉴얼에 제시된 통신 속도는 9600 이었다. 이걸로 여러번 시도를 해보았고 되지 않는 걸 보며 모터 불량을 생각하였고 통신 속도 및 다른 부분을 시도할 생각을 하지 못하였다. 똑같은 걸로 하나만 시도한다고 되는 게 아니라 여러가지 가능성을 열어두고 이것저것 해봐야 하는 걸 배웠다.

2. 너무 외부 라이브러리에 의존하지 않는 점이다
  - Modbus도 기본은 Serial이다. 하지만 외부 모듈만 찾는데 급급하여 외부 모듈만 사용하였고 큰 틀 내가 맞추어 가니 불편한 점 또한 많았다. 로깅 메세지 또한 그런 문제였다. 메세지를 내가 원하는 양 만큼 받아오면서 주소를 해석하여 모터의 상태를 불러 올 수 있게 되었다.

3. 알고리즘이 얼마나 중요한지 알게 되었다
  - 프로그램은 알고리즘을 작성한대로 구현하게 된다면 추가적인 필요한 부분이 생겼을 경우 추가가 쉽지만 만약 그렇지 않은 경우 모듈을 하나 둘 추가하다 보면 코드가 어려워진다. 필요한 기능을 정리 후 하나 둘 성성 및 연계 시켜야한다는 점을 꺠닭았다.

4. 바이트가 꺠져서 보이는 현상
- 꺠지는 게 아니었다. 그냥 일정값 이상 부터는 아스키코드로 변환되어서 문자로 보이는 것 뿐이었다. for문으로 부분마다 받아와주면 알아보기 쉽게 정수로 변환하여 준다.

------------------------------------------------------------

  - 아두이노 우노
- 사용 프로그램
  - 아두이노IDE
- 제작기간
  - 1달
- 통신방식
 - 모터 <-> 아두이노 : I/O
 - 아두이노 <-> PC : 시리얼

1. I/O 방식
   - I/O 안에도 크게 2가지 방식이 있다. 디지털은 신호 0,1을 불연속적인 신호, 아날로그 신호 연속적인 신호를 이용하여 입력하는 방식이다.
   - 예를 들어 전구의 전원을 켜는 방식은 디지털 제어에 가깝다. 켜지거나 꺼지거나 하는 2가지의 경우의 수 밖에 없으니까, 하지만 밝기를 조절하는 건 아날로그라고 볼 수 있다.
   - 펄스 제어는 디지털 방식에 가깝다. 0과 1의 신호를 번갈아 가면서 1주기라는 개념으로 제어를 한다.
   - 1주기 = T = 1/f 이다. 이 단위는 1초 단위이다.
   - 1주기는 신호가 HIGH 에서 LOW로 변한 후 다시 HIGH 되기까지의 시간을 말한다.
      _______        
      |     |       |
      |     |_______|

      |<---1주기--->|

2. 모터 관련
   - 모터의 속도는 가변저항을 이용한 전압으로 제어가 가능하고 혹은 펄스를 입력하여 속도가 조절이 가능하다.
   - 드라이버와 같이 딸려오는 케이블이 있는데 이 케이블은 가변 저항을 활용하여 저항이 낮아지면 속도가 점점 빨라지는 방식이다. 저항이 줄어들어 전압이 강해지면 모터도 쓸 수 있는 에너지가 많으니까 속도도 빨라진다고 생각하면 편할 거 같다.

3. 엔코더 관련
   - 엔코더는 증분식, 절대식이 있다. 증분식은 상대적인 방식, 절대식은 말그대로 절대적 방식이다.
   - 절대식은 Absolute, 증분식은 Incrementa Encoder라고도 부른다.
   - 둘 다 광학신호를 이용하지만 증분식은 일정 간격에 배열된 슬롯의 수를 측정하여 카운트하는 방식이고, 절대식은 슬롯에 이진코드를 작성하여 광학센서를 이용해 값을 읽는 방식으로 자신의 위치를 기억할 수 있다.
   - 구매한 GGM의 모터 드라이버인 GUB는 엔코더 출력이 라인 드라이버 방식이다. 오픈 콜렉터와 라인 드라이버 방식이 있는데 오픈 콜렉터는 정확하게는 이해하지 못하였지만 트랜지스터를 ON/OFF 하여 전류량을 10mA 정도로 이 전류를 만족하면, DC 5 ~ 24V에 유연하게 대처할 수 있다. 라인 드라이버 방식은 1개의 신호가 나오면 그 신호를 반전시켜 2개로 출력한다.
   - 라인 드라이버 방식에도 Single_ended 방식 Defferential 방식이 있다.
   - Single_ended는 하나의 그라운드를 이용해서 +,- 신호인지 구분하는 방식으로 rs-232통신이 이에 해당한다
   - Defferential은 2개의 신호를 이용하여 기존 신호를 반전 시켜 2개의 신호를 출력시킨다. 이 2개의 신호를 전달하여 끝단에서 다시 합치는 방식으로 받는 쪽은 라인 리시버 IC가 필요하다. 주파수가 높을수록 노이즈에 강하다는 장점이 있는데 
   
